<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mini Mario-Maker (HTML) — Plumber Player</title>
<style>
  :root { --bg:#0e1320; --ink:#e6e8ef; --muted:#99a1b3; --accent:#4f8cff; --good:#2ecc71; --bad:#e74c3c; }
  * { box-sizing: border-box; }
  body { margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; color: var(--ink); background: linear-gradient(180deg,#0b1020, #0a0f1b 60%, #080d18);}
  header { display:flex; gap:.75rem; align-items:center; padding:.75rem 1rem; border-bottom:1px solid #1b2133; position:sticky; top:0; background:#0c1222ee; backdrop-filter: blur(6px); z-index:10; }
  header h1 { font-size:1rem; margin:0 .75rem 0 0; color:#cfd6e6; white-space:nowrap; }
  .row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
  button, select, input[type=file] { background:#121a2c; color:var(--ink); border:1px solid #22304d; border-radius:10px; padding:.5rem .7rem; cursor:pointer; font-weight:600; }
  button:hover, select:hover { border-color:#33528a; }
  button[aria-pressed="true"] { background:#11203b; border-color: var(--accent); }
  .chip { padding:.35rem .6rem; border-radius:999px; font-size:.85rem; border:1px solid #24314d; color:#cfd6e6; }
  #wrap { display:grid; grid-template-columns: 260px 1fr; min-height: calc(100vh - 60px); }
  #sidebar { border-right:1px solid #1b2133; padding:12px; }
  #sidebar h3 { margin:10px 0 6px; font-size:.9rem; color:#cfd6e6; }
  .palette { display:grid; grid-template-columns:repeat(3, 64px); gap:8px; }
  .tilebtn { width:64px; height:64px; border-radius:10px; display:grid; place-items:center; position:relative; }
  .tilebtn[data-selected="true"] { outline:2px solid var(--accent); }
  .tiny { font-size:.8rem; color:var(--muted); }
  #canvasWrap { position:relative; background:#0a1020; }
  #game { display:block; width:100%; height:calc(100vh - 60px); background:#0a1020; image-rendering: pixelated; }
  #hud { position:absolute; left:8px; top:8px; padding:.3rem .5rem; border-radius:8px; background:#0b1426aa; border:1px solid #1b2133; font-weight:700; }
  #status { color:#cfd6e6; }
  .key { border:1px solid #27324a; background:#121a2c; border-radius:6px; padding:.15rem .35rem; font-weight:800; }
  .row .sep { width:1px; height:26px; background:#1b2133; margin:0 4px; }
</style>
</head>
<body>
  <header>
    <h1>Mini Mario-Maker (HTML)</h1>
    <div class="row">
      <button id="modeBtn" title="Toggle Edit/Play (E)"><span id="modeLbl">Edit</span> mode</button>
      <button id="saveBtn" title="Save to JSON (S)">Save</button>
      <label for="loadFile" class="chip" title="Load JSON (L)">Load JSON</label>
      <input id="loadFile" type="file" accept="application/json" style="display:none" />
      <div class="sep"></div>
      <button id="spawnBtn" title="Set spawn at cursor">Set Spawn</button>
      <button id="resetBtn" title="Reset to spawn (R)">Reset</button>
      <div class="sep"></div>
      <label class="chip">Layer:
        <select id="layerSel" title="Cycle (Tab)">
          <option value="0">Base (solid)</option>
          <option value="1">Hazards/Items</option>
          <option value="2">Deco</option>
        </select>
      </label>
      <label class="chip">Brush:
        <select id="brushSel">
          <option value="paint">Paint (LMB)</option>
          <option value="erase">Erase (RMB / X)</option>
        </select>
      </label>
      <div class="sep"></div>
      <span class="tiny">Move: <span class="key">A</span>/<span class="key">D</span>, Jump: <span class="key">Space</span>, Toggle: <span class="key">E</span></span>
    </div>
  </header>

  <div id="wrap">
    <aside id="sidebar">
      <h3>Tiles (1–6)</h3>
      <div class="palette" id="palette"></div>
      <p class="tiny">Tip: <b>Tab</b> to switch layer, <b>S</b> save, <b>L</b> load, <b>R</b> reset.</p>
      <h3>Legend</h3>
      <ul class="tiny">
        <li><b>Ground/Brick/Question</b> → Solid colliders</li>
        <li><b>Spike</b> → Death/respawn</li>
        <li><b>Coin</b> → Collectible</li>
        <li><b>Flag</b> → Level complete</li>
      </ul>
    </aside>

    <main id="canvasWrap">
      <canvas id="game" width="1280" height="720"></canvas>
      <div id="hud"><span id="status">Edit</span> · Coins: <span id="coins">0</span></div>
    </main>
  </div>

<script>
/* ===========================
   CONFIG
=========================== */
const TILE = 32;
const GRID_W = 100, GRID_H = 40;
const GRAVITY = 2000;
const MOVE_SPEED = 260;
const JUMP_FORCE = 700;
const MAX_FALL = 1200;
const CAMERA_LERP = 10;

/* ===========================
   TILE DEFINITIONS
=========================== */
const TILES = [
  { id:0, name:"Empty",  key:null,   solid:false, draw:ctx=>{} },
  { id:1, name:"Ground", key:"1",    solid:true,  draw:tileSkin("#6b4d2e","#8a5e36","#4a361f") },
  { id:2, name:"Brick",  key:"2",    solid:true,  draw:brickSkin() },
  { id:3, name:"Question", key:"3",  solid:true,  draw:questionSkin() },
  { id:4, name:"Spike",  key:"4",    solid:false, draw:spikeSkin(), hazard:true },
  { id:5, name:"Coin",   key:"5",    solid:false, draw:coinSkin(),  coin:true },
  { id:6, name:"Flag",   key:"6",    solid:false, draw:flagSkin(),  goal:true },
];

function tileSkin(base, mid, dark){
  return (ctx,x,y)=> {
    ctx.fillStyle = base; ctx.fillRect(x,y,TILE,TILE);
    ctx.fillStyle = mid;  ctx.fillRect(x+2,y+2,TILE-4,TILE-4);
    ctx.fillStyle = dark; ctx.fillRect(x,y+TILE-4,TILE,4);
  };
}
function brickSkin(){
  return (ctx,x,y)=>{
    ctx.fillStyle="#8b5540"; ctx.fillRect(x,y,TILE,TILE);
    ctx.fillStyle="#5a3628";
    ctx.fillRect(x, y+10, TILE, 4);
    ctx.fillRect(x, y+20, TILE, 4);
    ctx.fillRect(x+10, y, 4, TILE);
    ctx.fillRect(x+20, y, 4, TILE);
  };
}
function questionSkin(){
  return (ctx,x,y)=>{
    ctx.fillStyle="#cfa02c"; ctx.fillRect(x,y,TILE,TILE);
    ctx.strokeStyle="#5d3b00"; ctx.lineWidth=3;
    ctx.strokeRect(x+1.5,y+1.5,TILE-3,TILE-3);
    ctx.fillStyle="#5d3b00";
    ctx.font="bold 20px monospace";
    ctx.fillText("?", x+10, y+22);
  };
}
function spikeSkin(){
  return (ctx,x,y)=>{
    ctx.fillStyle="#444c5e"; ctx.fillRect(x,y,TILE,TILE);
    ctx.fillStyle="#cfd6e6";
    for(let i=0;i<4;i++){
      const bx=x+i*8+4, by=y+TILE-2;
      ctx.beginPath(); ctx.moveTo(bx-4,by); ctx.lineTo(bx, y+6); ctx.lineTo(bx+4,by); ctx.closePath(); ctx.fill();
    }
  };
}
function coinSkin(){
  return (ctx,x,y)=>{
    ctx.fillStyle="#0b1426"; ctx.fillRect(x,y,TILE,TILE);
    ctx.fillStyle="#ffd24a"; ctx.beginPath();
    ctx.arc(x+TILE/2,y+TILE/2,10,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle="#a27a16"; ctx.lineWidth=2; ctx.stroke();
  };
}
function flagSkin(){
  return (ctx,x,y)=>{
    ctx.fillStyle="#0b1426"; ctx.fillRect(x,y,TILE,TILE);
    ctx.fillStyle="#ccc"; ctx.fillRect(x+12,y+4,4,TILE-8);
    ctx.fillStyle="#2ecc71"; ctx.beginPath();
    ctx.moveTo(x+16,y+6); ctx.lineTo(x+26,y+12); ctx.lineTo(x+16,y+18); ctx.closePath(); ctx.fill();
  };
}

/* ===========================
   STATE
=========================== */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const hudStatus = document.getElementById('status');
const hudCoins = document.getElementById('coins');

const modeBtn = document.getElementById('modeBtn');
const modeLbl = document.getElementById('modeLbl');
const saveBtn = document.getElementById('saveBtn');
const loadFile = document.getElementById('loadFile');
const layerSel = document.getElementById('layerSel');
const spawnBtn = document.getElementById('spawnBtn');
const resetBtn = document.getElementById('resetBtn');
const brushSel = document.getElementById('brushSel');

let editMode = true;
let activeLayer = 0;
let activeTile = 1;
let brush = 'paint';

let map = [
  createGrid(GRID_W, GRID_H, 0),
  createGrid(GRID_W, GRID_H, 0),
  createGrid(GRID_W, GRID_H, 0)
];

let spawn = {x: 3*TILE, y: 5*TILE};
let coinsCollected = 0;

const player = {
  x: spawn.x, y: spawn.y, w: 22, h: 28,
  vx: 0, vy: 0, onGround: false, facing: 1, dead:false, win:false,
  animTime: 0, // seconds
  state: 'idle' // idle|run|jump
};

const camera = { x:0, y:0 };

function createGrid(w,h,fill=0){ return Array.from({length:h}, ()=> Array(w).fill(fill)); }

/* ===========================
   INPUT
=========================== */
const keys = new Set();
window.addEventListener('keydown', e=>{
  if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," "].includes(e.key)) e.preventDefault();
  keys.add(e.key.toLowerCase());

  if (e.key.toLowerCase()==='e') toggleMode();
  if (e.key.toLowerCase()==='tab'){ e.preventDefault(); cycleLayer(); }
  if (e.key.toLowerCase()==='s') { if (editMode) saveJSON(); }
  if (e.key.toLowerCase()==='l') { if (editMode) loadFile.click(); }
  if (e.key.toLowerCase()==='r') resetToSpawn();
  if (e.key.toLowerCase()==='x') brushSel.value = brush = 'erase';

  const num = Number(e.key);
  if ([1,2,3,4,5,6].includes(num)) selectTile(num);
});
window.addEventListener('keyup', e=> keys.delete(e.key.toLowerCase()));
canvas.addEventListener('contextmenu', e=> e.preventDefault());

let mouse = {x:0,y:0, down:false, rdown:false};
canvas.addEventListener('mousemove', e=>{
  const rect = canvas.getBoundingClientRect();
  mouse.x = (e.clientX - rect.left);
  mouse.y = (e.clientY - rect.top);
});
canvas.addEventListener('mousedown', e=>{
  if (e.button===0) mouse.down = true;
  if (e.button===2) mouse.rdown = true;
});
window.addEventListener('mouseup', e=>{
  if (e.button===0) mouse.down = false;
  if (e.button===2) mouse.rdown = false;
});

function worldMouse(){
  return { x: camera.x + mouse.x, y: camera.y + mouse.y };
}
function cellUnderMouse(){
  const wm = worldMouse();
  return { cx: Math.floor(wm.x / TILE), cy: Math.floor(wm.y / TILE) };
}

/* ===========================
   UI
=========================== */
modeBtn.onclick = toggleMode;
saveBtn.onclick = saveJSON;
loadFile.onchange = handleLoad;
layerSel.onchange = e => activeLayer = Number(e.target.value);
spawnBtn.onclick = () => { const {cx,cy}=cellUnderMouse(); spawn.x=cx*TILE; spawn.y=cy*TILE; flash("Spawn set"); };
resetBtn.onclick = resetToSpawn;
brushSel.onchange = e => brush = e.target.value;

function toggleMode(){
  editMode = !editMode;
  modeLbl.textContent = editMode ? "Edit" : "Play";
  modeBtn.setAttribute('aria-pressed', String(!editMode));
  hudStatus.textContent = editMode ? "Edit" : "Play";
  if (editMode){ player.vx = player.vy = 0; player.state='idle'; }
  else resetToSpawn();
}
function cycleLayer(){
  activeLayer = (activeLayer+1)%3;
  layerSel.value = String(activeLayer);
}
function selectTile(id){
  activeTile = id;
  [...document.querySelectorAll('.tilebtn')].forEach(b=> b.dataset.selected = (Number(b.dataset.id)===id));
}

/* ===========================
   PALETTE
=========================== */
const palette = document.getElementById('palette');
for (const t of TILES.filter(t=>t.id!==0)) {
  const btn = document.createElement('button');
  btn.className = 'tilebtn';
  btn.title = `${t.name} (${t.key || t.id})`;
  btn.dataset.id = t.id;
  const cv = document.createElement('canvas');
  cv.width=cv.height=64; const c=cv.getContext('2d');
  c.imageSmoothingEnabled = false;
  t.draw(c,0,0);
  const tmp = document.createElement('canvas'); tmp.width=tmp.height=32; const tc=tmp.getContext('2d');
  t.draw(tc,0,0);
  c.save(); c.scale(2,2); c.drawImage(tmp,0,0); c.restore();
  btn.appendChild(cv);
  btn.onclick = ()=> selectTile(t.id);
  palette.appendChild(btn);
}
selectTile(1);

/* ===========================
   SAVE / LOAD
=========================== */
function serialize(){
  const cells = [];
  for (let l=0; l<3; l++){
    for (let y=0; y<GRID_H; y++){
      for (let x=0; x<GRID_W; x++){
        const id = map[l][y][x];
        if (id!==0) cells.push({x,y,id,layer:l});
      }
    }
  }
  return { w: GRID_W, h: GRID_H, cells, spawn };
}
function deserialize(data){
  map = [createGrid(GRID_W, GRID_H, 0), createGrid(GRID_W, GRID_H, 0), createGrid(GRID_W, GRID_H, 0)];
  for (const c of data.cells){
    if (c.layer>=0 && c.layer<3 && c.x>=0 && c.x<GRID_W && c.y>=0 && c.y<GRID_H){
      map[c.layer][c.y][c.x] = c.id;
    }
  }
  if (data.spawn) spawn = {...data.spawn};
  resetToSpawn();
}
function saveJSON(){
  const data = serialize();
  const blob = new Blob([JSON.stringify(data,null,2)], {type:'application/json'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'level.json';
  a.click();
  URL.revokeObjectURL(a.href);
  flash("Saved level.json");
}
function handleLoad(e){
  const file = e.target.files[0]; if (!file) return;
  const reader = new FileReader();
  reader.onload = () => {
    try { deserialize(JSON.parse(reader.result)); flash("Level loaded"); }
    catch(err){ alert("Invalid JSON"); console.error(err); }
  };
  reader.readAsText(file);
  e.target.value = '';
}

/* ===========================
   EDITOR
=========================== */
function editorUpdate(dt){
  const {cx,cy} = cellUnderMouse();
  if (cx>=0 && cy>=0 && cx<GRID_W && cy<GRID_H){
    if (mouse.down && brush==='paint') map[activeLayer][cy][cx] = activeTile;
    if ((mouse.rdown) || (mouse.down && brush==='erase')) map[activeLayer][cy][cx] = 0;
  }
  const targetX = Math.max(0, Math.min(cx*TILE - canvas.width/2 + TILE/2, GRID_W*TILE - canvas.width));
  const targetY = Math.max(0, Math.min(cy*TILE - canvas.height/2 + TILE/2, GRID_H*TILE - canvas.height));
  camera.x += (targetX - camera.x) * Math.min(1, dt * CAMERA_LERP);
  camera.y += (targetY - camera.y) * Math.min(1, dt * CAMERA_LERP);
}

/* ===========================
   PHYSICS / COLLISION
=========================== */
function resetToSpawn(){
  player.x = spawn.x;
  player.y = spawn.y;
  player.vx = player.vy = 0;
  player.onGround=false; player.dead=false; player.win=false;
  player.state='idle'; player.animTime=0;
  coinsCollected = 0;
  hudCoins.textContent = '0';
  flash("Respawned");
}
function isSolid(id){ return id===1 || id===2 || id===3; }

function collideAABBWithMap(px,py,pw,ph, vx,vy, dt){
  let x = px + vx * dt;
  let y = py;

  const tilesX = tilesInAABB(Math.min(px,x), y, Math.max(px,x)+pw, y+ph);
  for (const t of tilesX){
    const id = map[0][t.y][t.x];
    if (isSolid(id)){
      const tx = t.x*TILE, ty = t.y*TILE;
      if (rectsOverlap(x,y,pw,ph, tx,ty,TILE,TILE)){
        if (vx>0) x = tx - pw; else if (vx<0) x = tx + TILE;
        vx = 0;
      }
    }
  }

  y += vy * dt;
  const tilesY = tilesInAABB(x, Math.min(py,y), x+pw, Math.max(py,y)+ph);
  let onGround = false;
  let coinsDelta = 0;
  let dead = false, win = false;

  for (const t of tilesY){
    const bx = t.x*TILE, by=t.y*TILE;

    const id0 = map[0][t.y][t.x];
    if (isSolid(id0) && rectsOverlap(x,y,pw,ph, bx,by,TILE,TILE)){
      if (vy>0){ y = by - ph; vy = 0; onGround = true; }
      else if (vy<0){ y = by + TILE; vy = 0; }
    }

    const id1 = map[1][t.y][t.x];
    if (id1===4 && rectsOverlap(x,y,pw,ph, bx,by,TILE,TILE)) dead = true;
    if (id1===5 && rectsOverlap(x,y,pw,ph, bx,by,TILE,TILE)){ map[1][t.y][t.x]=0; coinsDelta += 1; }
    if (id1===6 && rectsOverlap(x,y,pw,ph, bx,by,TILE,TILE)) win = true;
  }

  return { x,y,vx,vy,onGround,dead,win,coinsDelta };
}

function rectsOverlap(ax,ay,aw,ah, bx,by,bw,bh){
  return ax < bx+bw && ax+aw > bx && ay < by+bh && ay+ah > by;
}
function tilesInAABB(x1,y1,x2,y2){
  const cx1 = Math.max(0, Math.floor(x1 / TILE));
  const cy1 = Math.max(0, Math.floor(y1 / TILE));
  const cx2 = Math.min(GRID_W-1, Math.floor((x2-0.001) / TILE));
  const cy2 = Math.min(GRID_H-1, Math.floor((y2-0.001) / TILE));
  const out = [];
  for (let y=cy1; y<=cy2; y++) for (let x=cx1; x<=cx2; x++) out.push({x,y});
  return out;
}

/* ===========================
   GAME LOOP
=========================== */
let last = performance.now();
function loop(now){
  const dt = Math.min(1/30, (now-last)/1000); last = now;
  update(dt);
  render();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

function update(dt){
  if (editMode){ editorUpdate(dt); return; }

  const left  = keys.has('a') || keys.has('arrowleft');
  const right = keys.has('d') || keys.has('arrowright');
  const jump  = keys.has(' ') || keys.has('w') || keys.has('arrowup');

  player.vx = 0;
  if (left)  { player.vx = -MOVE_SPEED; player.facing = -1; }
  if (right) { player.vx =  MOVE_SPEED; player.facing =  1; }

  player.vy += GRAVITY * dt;
  if (player.vy > MAX_FALL) player.vy = MAX_FALL;

  if (jump && player.onGround){
    player.vy = -JUMP_FORCE;
    player.onGround = false;
  }

  const res = collideAABBWithMap(player.x, player.y, player.w, player.h, player.vx, player.vy, dt);
  player.x = res.x; player.y = res.y; player.vx = res.vx; player.vy = res.vy; player.onGround = res.onGround;

  // animation state
  player.animTime += dt;
  if (!player.onGround) player.state = 'jump';
  else if (Math.abs(player.vx) > 1) player.state = 'run';
  else player.state = 'idle';

  if (res.coinsDelta){ hudCoins.textContent = String(Number(hudCoins.textContent) + res.coinsDelta); flash("+1 coin"); }
  if (res.dead){ flash("Ouch! Respawned", 1000, 'var(--bad)'); resetToSpawn(); }
  if (res.win){ flash("Level Complete!", 1500, 'var(--good)'); toggleMode(); }

  const targetX = Math.max(0, Math.min(player.x + player.w/2 - canvas.width/2, GRID_W*TILE - canvas.width));
  const targetY = Math.max(0, Math.min(player.y + player.h/2 - canvas.height/2, GRID_H*TILE - canvas.height));
  camera.x += (targetX - camera.x) * Math.min(1, dt * CAMERA_LERP);
  camera.y += (targetY - camera.y) * Math.min(1, dt * CAMERA_LERP);
}

/* ===========================
   RENDER
=========================== */
function render(){
  ctx.imageSmoothingEnabled = false;
  ctx.fillStyle = '#071022';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  ctx.save();
  ctx.translate(-camera.x|0, -camera.y|0);

  drawBackground();
  drawLayer(0);
  drawLayer(1);
  drawLayer(2);

  if (editMode){
    ctx.strokeStyle = '#4f8cffaa'; ctx.lineWidth = 2;
    ctx.strokeRect(spawn.x|0, spawn.y|0, TILE, TILE);
  }

  drawPlayer();

  if (editMode){
    const {cx,cy} = cellUnderMouse();
    if (cx>=0 && cy>=0 && cx<GRID_W && cy<GRID_H){
      ctx.strokeStyle = 'rgba(255,255,255,0.4)';
      ctx.strokeRect(cx*TILE+0.5, cy*TILE+0.5, TILE-1, TILE-1);
      if (brush==='paint' && activeTile!==0){
        ctx.globalAlpha = 0.6;
        TILES[activeTile].draw(ctx, cx*TILE, cy*TILE);
        ctx.globalAlpha = 1;
      }
    }
  }

  ctx.restore();
}

function drawBackground(){
  const g = ctx.createLinearGradient(0, camera.y, 0, camera.y + canvas.height);
  g.addColorStop(0, '#0a1630'); g.addColorStop(1, '#0a1226');
  ctx.fillStyle = g; ctx.fillRect(camera.x, camera.y, canvas.width, canvas.height);

  ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.lineWidth=1;
  const startX = Math.floor(camera.x / TILE) * TILE;
  const endX = camera.x + canvas.width + TILE;
  const startY = Math.floor(camera.y / TILE) * TILE;
  const endY = camera.y + canvas.height + TILE;
  for (let x=startX; x<=endX; x+=TILE){ ctx.beginPath(); ctx.moveTo(x,startY); ctx.lineTo(x,endY); ctx.stroke(); }
  for (let y=startY; y<=endY; y+=TILE){ ctx.beginPath(); ctx.moveTo(startX,y); ctx.lineTo(endX,y); ctx.stroke(); }
}

function drawLayer(layer){
  for (let y=0; y<GRID_H; y++){
    for (let x=0; x<GRID_W; x++){
      const id = map[layer][y][x];
      if (id!==0){
        const t = TILES[id];
        t.draw(ctx, x*TILE, y*TILE);
      }
    }
  }
}

/* ===========================
   PLUMBER SPRITE (procedural)
=========================== */
function drawPlayer(){
  const px = player.x|0, py = player.y|0;
  const facing = player.facing;
  const t = player.animTime;

  // base body box for collisions:
  // player.w=22, player.h=28; sprite drawn a bit larger around it.
  ctx.save();
  ctx.translate(px + player.w/2, py + player.h/2);

  // flip for facing
  ctx.scale(facing, 1);
  ctx.translate(-player.w/2, -player.h/2);

  // choose frame by state
  if (player.state==='idle') drawPlumberIdle(ctx);
  else if (player.state==='run') drawPlumberRun(ctx, t);
  else drawPlumberJump(ctx);

  ctx.restore();
}

// simple palette
const P = {
  skin: "#ffcc99",
  hair: "#5a3112",
  hat:  "#d33a2c",   // red cap
  shirt:"#e0472f",
  over:"#2e6dd1",    // blue overalls
  trim:"#103a86",
  glove:"#f3f5ff",
  boot:"#5c3b20",
  shade:"#00000022"
};

function drawPlumberIdle(c){
  // drop shadow
  c.fillStyle=P.shade; c.fillRect(2,26,18,2);

  // boots
  c.fillStyle=P.boot; c.fillRect(2,22,7,4); c.fillRect(13,22,7,4);

  // legs/overalls
  c.fillStyle=P.over; c.fillRect(3,14,16,9);
  c.fillStyle=P.trim; c.fillRect(3,20,16,1);

  // shirt sleeves peeking
  c.fillStyle=P.shirt; c.fillRect(0,12,4,4); c.fillRect(18,12,4,4);

  // torso
  c.fillStyle=P.shirt; c.fillRect(5,10,12,8);

  // gloves
  c.fillStyle=P.glove; c.fillRect(-1,14,4,4); c.fillRect(19,14,4,4);

  // head
  c.fillStyle=P.skin; c.fillRect(6,3,10,7);

  // hair side
  c.fillStyle=P.hair; c.fillRect(5,6,2,4);

  // cap
  c.fillStyle=P.hat; c.fillRect(4,1,14,3); c.fillRect(3,2,16,2);

  // eyes / mustache
  c.fillStyle="#222"; c.fillRect(8,6,2,2); c.fillRect(12,6,2,2);
  c.fillRect(7,8,8,2);
}

function drawPlumberRun(c, t){
  // simple two-frame leg swing
  const phase = Math.sin(t*10);
  const leftUp = phase>0;

  c.fillStyle=P.shade; c.fillRect(2,26,18,2);

  // boots (animated)
  c.fillStyle=P.boot;
  if (leftUp){ c.fillRect(2,21,7,5); c.fillRect(13,23,7,3); }
  else       { c.fillRect(2,23,7,3); c.fillRect(13,21,7,5); }

  // overalls legs
  c.fillStyle=P.over;
  if (leftUp){ c.fillRect(3,14,7,9); c.fillRect(12,16,7,7); }
  else       { c.fillRect(3,16,7,7); c.fillRect(12,14,7,9); }
  c.fillStyle=P.trim; c.fillRect(3,20,16,1);

  // swinging arms
  c.fillStyle=P.shirt;
  if (leftUp){ c.fillRect(0,11,4,5); c.fillRect(18,12,4,5); }
  else       { c.fillRect(0,12,4,5); c.fillRect(18,11,4,5); }
  c.fillStyle=P.glove;
  if (leftUp){ c.fillRect(-1,14,4,4); c.fillRect(19,15,4,4); }
  else       { c.fillRect(-1,15,4,4); c.fillRect(19,14,4,4); }

  // torso
  c.fillStyle=P.shirt; c.fillRect(5,10,12,8);

  // head + cap
  c.fillStyle=P.skin; c.fillRect(6,3,10,7);
  c.fillStyle=P.hair; c.fillRect(5,6,2,4);
  c.fillStyle=P.hat;  c.fillRect(4,1,14,3); c.fillRect(3,2,16,2);

  // face details
  c.fillStyle="#222"; c.fillRect(8,6,2,2); c.fillRect(12,6,2,2);
  c.fillRect(7,8,8,2);
}

function drawPlumberJump(c){
  c.fillStyle=P.shade; c.fillRect(2,26,18,2);

  // tucked boots
  c.fillStyle=P.boot; c.fillRect(2,21,7,4); c.fillRect(13,21,7,4);

  // overalls
  c.fillStyle=P.over; c.fillRect(3,14,16,8);
  c.fillStyle=P.trim; c.fillRect(3,19,16,1);

  // arms up
  c.fillStyle=P.shirt; c.fillRect(0,9,4,6); c.fillRect(18,9,4,6);
  c.fillStyle=P.glove; c.fillRect(-1,9,4,4); c.fillRect(19,9,4,4);

  // torso
  c.fillStyle=P.shirt; c.fillRect(5,10,12,8);

  // head + cap
  c.fillStyle=P.skin; c.fillRect(6,3,10,7);
  c.fillStyle=P.hair; c.fillRect(5,6,2,4);
  c.fillStyle=P.hat;  c.fillRect(4,1,14,3); c.fillRect(3,2,16,2);

  c.fillStyle="#222"; c.fillRect(8,6,2,2); c.fillRect(12,6,2,2);
  c.fillRect(7,8,8,2);
}

/* ===========================
   TOOLS
=========================== */
function flash(msg, ms=700, color='var(--accent)'){
  const el = document.createElement('div');
  el.textContent = msg;
  el.style.position='absolute';
  el.style.right='10px'; el.style.top='10px';
  el.style.padding='.35rem .6rem'; el.style.borderRadius='8px';
  el.style.background='#0b1426cc'; el.style.border='1px solid #1b2133';
  el.style.color = 'white'; el.style.fontWeight='700';
  el.style.boxShadow='0 6px 16px rgba(0,0,0,.3)';
  el.style.pointerEvents='none';
  el.style.transition='all .25s ease';
  document.body.appendChild(el);
  setTimeout(()=>{ el.style.opacity='0'; el.style.transform='translateY(-6px)'; }, ms);
  setTimeout(()=> el.remove(), ms+300);
}

/* ===========================
   DEFAULT SAMPLE LEVEL
=========================== */
(function seed(){
  for (let x=0; x<GRID_W; x++){
    const baseY = 28 + (x%7===0? -1:0);
    for (let y=baseY; y<GRID_H; y++) map[0][y][x] = 1;
  }
  map[0][23][10]=2; map[0][23][11]=3; map[0][23][12]=2;
  for (let x=18; x<=20; x++) map[1][27][x] = 4;
  map[1][22][11]=5; map[1][22][12]=5; map[1][22][13]=5;
  map[1][24][28]=6;
  spawn = {x: 6*TILE, y: 20*TILE};
  resetToSpawn();
})();
</script>
</body>
</html>
